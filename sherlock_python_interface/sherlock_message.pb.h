// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sherlock_message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sherlock_5fmessage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sherlock_5fmessage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sherlock_5fmessage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sherlock_5fmessage_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sherlock_5fmessage_2eproto;
namespace sherlock {
class interval;
class intervalDefaultTypeInternal;
extern intervalDefaultTypeInternal _interval_default_instance_;
class linear_combo;
class linear_comboDefaultTypeInternal;
extern linear_comboDefaultTypeInternal _linear_combo_default_instance_;
class mapping;
class mappingDefaultTypeInternal;
extern mappingDefaultTypeInternal _mapping_default_instance_;
class network;
class networkDefaultTypeInternal;
extern networkDefaultTypeInternal _network_default_instance_;
class objective;
class objectiveDefaultTypeInternal;
extern objectiveDefaultTypeInternal _objective_default_instance_;
class sherlock_message;
class sherlock_messageDefaultTypeInternal;
extern sherlock_messageDefaultTypeInternal _sherlock_message_default_instance_;
}  // namespace sherlock
PROTOBUF_NAMESPACE_OPEN
template<> ::sherlock::interval* Arena::CreateMaybeMessage<::sherlock::interval>(Arena*);
template<> ::sherlock::linear_combo* Arena::CreateMaybeMessage<::sherlock::linear_combo>(Arena*);
template<> ::sherlock::mapping* Arena::CreateMaybeMessage<::sherlock::mapping>(Arena*);
template<> ::sherlock::network* Arena::CreateMaybeMessage<::sherlock::network>(Arena*);
template<> ::sherlock::objective* Arena::CreateMaybeMessage<::sherlock::objective>(Arena*);
template<> ::sherlock::sherlock_message* Arena::CreateMaybeMessage<::sherlock::sherlock_message>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sherlock {

enum objective_optimization_status : int {
  objective_optimization_status_NOT_STARTED = 0,
  objective_optimization_status_STARTED = 1,
  objective_optimization_status_DONE = 2,
  objective_optimization_status_objective_optimization_status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  objective_optimization_status_objective_optimization_status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool objective_optimization_status_IsValid(int value);
constexpr objective_optimization_status objective_optimization_status_optimization_status_MIN = objective_optimization_status_NOT_STARTED;
constexpr objective_optimization_status objective_optimization_status_optimization_status_MAX = objective_optimization_status_DONE;
constexpr int objective_optimization_status_optimization_status_ARRAYSIZE = objective_optimization_status_optimization_status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* objective_optimization_status_descriptor();
template<typename T>
inline const std::string& objective_optimization_status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, objective_optimization_status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function objective_optimization_status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    objective_optimization_status_descriptor(), enum_t_value);
}
inline bool objective_optimization_status_Parse(
    const std::string& name, objective_optimization_status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<objective_optimization_status>(
    objective_optimization_status_descriptor(), name, value);
}
// ===================================================================

class network :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sherlock.network) */ {
 public:
  network();
  virtual ~network();

  network(const network& from);
  network(network&& from) noexcept
    : network() {
    *this = ::std::move(from);
  }

  inline network& operator=(const network& from) {
    CopyFrom(from);
    return *this;
  }
  inline network& operator=(network&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const network& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const network* internal_default_instance() {
    return reinterpret_cast<const network*>(
               &_network_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(network& a, network& b) {
    a.Swap(&b);
  }
  inline void Swap(network* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline network* New() const final {
    return CreateMaybeMessage<network>(nullptr);
  }

  network* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<network>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const network& from);
  void MergeFrom(const network& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(network* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sherlock.network";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sherlock_5fmessage_2eproto);
    return ::descriptor_table_sherlock_5fmessage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputNodeIndicesFieldNumber = 3,
    kOutputNodeIndicesFieldNumber = 4,
    kOnnxFilenameFieldNumber = 1,
    kOldFormatFilenameFieldNumber = 2,
  };
  // repeated int32 input_node_indices = 3;
  int input_node_indices_size() const;
  void clear_input_node_indices();
  ::PROTOBUF_NAMESPACE_ID::int32 input_node_indices(int index) const;
  void set_input_node_indices(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_input_node_indices(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      input_node_indices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_input_node_indices();

  // repeated int32 output_node_indices = 4;
  int output_node_indices_size() const;
  void clear_output_node_indices();
  ::PROTOBUF_NAMESPACE_ID::int32 output_node_indices(int index) const;
  void set_output_node_indices(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_output_node_indices(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      output_node_indices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_output_node_indices();

  // string onnx_filename = 1;
  void clear_onnx_filename();
  const std::string& onnx_filename() const;
  void set_onnx_filename(const std::string& value);
  void set_onnx_filename(std::string&& value);
  void set_onnx_filename(const char* value);
  void set_onnx_filename(const char* value, size_t size);
  std::string* mutable_onnx_filename();
  std::string* release_onnx_filename();
  void set_allocated_onnx_filename(std::string* onnx_filename);

  // string old_format_filename = 2;
  void clear_old_format_filename();
  const std::string& old_format_filename() const;
  void set_old_format_filename(const std::string& value);
  void set_old_format_filename(std::string&& value);
  void set_old_format_filename(const char* value);
  void set_old_format_filename(const char* value, size_t size);
  std::string* mutable_old_format_filename();
  std::string* release_old_format_filename();
  void set_allocated_old_format_filename(std::string* old_format_filename);

  // @@protoc_insertion_point(class_scope:sherlock.network)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > input_node_indices_;
  mutable std::atomic<int> _input_node_indices_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > output_node_indices_;
  mutable std::atomic<int> _output_node_indices_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr onnx_filename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_format_filename_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sherlock_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class mapping :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sherlock.mapping) */ {
 public:
  mapping();
  virtual ~mapping();

  mapping(const mapping& from);
  mapping(mapping&& from) noexcept
    : mapping() {
    *this = ::std::move(from);
  }

  inline mapping& operator=(const mapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline mapping& operator=(mapping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const mapping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const mapping* internal_default_instance() {
    return reinterpret_cast<const mapping*>(
               &_mapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(mapping& a, mapping& b) {
    a.Swap(&b);
  }
  inline void Swap(mapping* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline mapping* New() const final {
    return CreateMaybeMessage<mapping>(nullptr);
  }

  mapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<mapping>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const mapping& from);
  void MergeFrom(const mapping& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mapping* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sherlock.mapping";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sherlock_5fmessage_2eproto);
    return ::descriptor_table_sherlock_5fmessage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIndexFieldNumber = 1,
    kUpperLimitFieldNumber = 2,
    kLowerLimitFieldNumber = 3,
  };
  // int32 node_index = 1;
  void clear_node_index();
  ::PROTOBUF_NAMESPACE_ID::int32 node_index() const;
  void set_node_index(::PROTOBUF_NAMESPACE_ID::int32 value);

  // float upper_limit = 2;
  void clear_upper_limit();
  float upper_limit() const;
  void set_upper_limit(float value);

  // float lower_limit = 3;
  void clear_lower_limit();
  float lower_limit() const;
  void set_lower_limit(float value);

  // @@protoc_insertion_point(class_scope:sherlock.mapping)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 node_index_;
  float upper_limit_;
  float lower_limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sherlock_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class interval :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sherlock.interval) */ {
 public:
  interval();
  virtual ~interval();

  interval(const interval& from);
  interval(interval&& from) noexcept
    : interval() {
    *this = ::std::move(from);
  }

  inline interval& operator=(const interval& from) {
    CopyFrom(from);
    return *this;
  }
  inline interval& operator=(interval&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const interval& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const interval* internal_default_instance() {
    return reinterpret_cast<const interval*>(
               &_interval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(interval& a, interval& b) {
    a.Swap(&b);
  }
  inline void Swap(interval* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline interval* New() const final {
    return CreateMaybeMessage<interval>(nullptr);
  }

  interval* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<interval>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const interval& from);
  void MergeFrom(const interval& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(interval* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sherlock.interval";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sherlock_5fmessage_2eproto);
    return ::descriptor_table_sherlock_5fmessage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLimitsFieldNumber = 1,
  };
  // repeated .sherlock.mapping limits = 1;
  int limits_size() const;
  void clear_limits();
  ::sherlock::mapping* mutable_limits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sherlock::mapping >*
      mutable_limits();
  const ::sherlock::mapping& limits(int index) const;
  ::sherlock::mapping* add_limits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sherlock::mapping >&
      limits() const;

  // @@protoc_insertion_point(class_scope:sherlock.interval)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sherlock::mapping > limits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sherlock_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class linear_combo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sherlock.linear_combo) */ {
 public:
  linear_combo();
  virtual ~linear_combo();

  linear_combo(const linear_combo& from);
  linear_combo(linear_combo&& from) noexcept
    : linear_combo() {
    *this = ::std::move(from);
  }

  inline linear_combo& operator=(const linear_combo& from) {
    CopyFrom(from);
    return *this;
  }
  inline linear_combo& operator=(linear_combo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const linear_combo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const linear_combo* internal_default_instance() {
    return reinterpret_cast<const linear_combo*>(
               &_linear_combo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(linear_combo& a, linear_combo& b) {
    a.Swap(&b);
  }
  inline void Swap(linear_combo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline linear_combo* New() const final {
    return CreateMaybeMessage<linear_combo>(nullptr);
  }

  linear_combo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<linear_combo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const linear_combo& from);
  void MergeFrom(const linear_combo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(linear_combo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sherlock.linear_combo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sherlock_5fmessage_2eproto);
    return ::descriptor_table_sherlock_5fmessage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoefficientFieldNumber = 1,
    kNodeIndexFieldNumber = 2,
  };
  // float coefficient = 1;
  void clear_coefficient();
  float coefficient() const;
  void set_coefficient(float value);

  // int32 node_index = 2;
  void clear_node_index();
  ::PROTOBUF_NAMESPACE_ID::int32 node_index() const;
  void set_node_index(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:sherlock.linear_combo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float coefficient_;
  ::PROTOBUF_NAMESPACE_ID::int32 node_index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sherlock_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class objective :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sherlock.objective) */ {
 public:
  objective();
  virtual ~objective();

  objective(const objective& from);
  objective(objective&& from) noexcept
    : objective() {
    *this = ::std::move(from);
  }

  inline objective& operator=(const objective& from) {
    CopyFrom(from);
    return *this;
  }
  inline objective& operator=(objective&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const objective& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const objective* internal_default_instance() {
    return reinterpret_cast<const objective*>(
               &_objective_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(objective& a, objective& b) {
    a.Swap(&b);
  }
  inline void Swap(objective* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline objective* New() const final {
    return CreateMaybeMessage<objective>(nullptr);
  }

  objective* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<objective>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const objective& from);
  void MergeFrom(const objective& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(objective* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sherlock.objective";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sherlock_5fmessage_2eproto);
    return ::descriptor_table_sherlock_5fmessage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef objective_optimization_status optimization_status;
  static constexpr optimization_status NOT_STARTED =
    objective_optimization_status_NOT_STARTED;
  static constexpr optimization_status STARTED =
    objective_optimization_status_STARTED;
  static constexpr optimization_status DONE =
    objective_optimization_status_DONE;
  static inline bool optimization_status_IsValid(int value) {
    return objective_optimization_status_IsValid(value);
  }
  static constexpr optimization_status optimization_status_MIN =
    objective_optimization_status_optimization_status_MIN;
  static constexpr optimization_status optimization_status_MAX =
    objective_optimization_status_optimization_status_MAX;
  static constexpr int optimization_status_ARRAYSIZE =
    objective_optimization_status_optimization_status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  optimization_status_descriptor() {
    return objective_optimization_status_descriptor();
  }
  template<typename T>
  static inline const std::string& optimization_status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, optimization_status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function optimization_status_Name.");
    return objective_optimization_status_Name(enum_t_value);
  }
  static inline bool optimization_status_Parse(const std::string& name,
      optimization_status* value) {
    return objective_optimization_status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLinearTermsFieldNumber = 1,
    kDirectionFieldNumber = 2,
    kStatusFlagFieldNumber = 3,
  };
  // repeated .sherlock.linear_combo linear_terms = 1;
  int linear_terms_size() const;
  void clear_linear_terms();
  ::sherlock::linear_combo* mutable_linear_terms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sherlock::linear_combo >*
      mutable_linear_terms();
  const ::sherlock::linear_combo& linear_terms(int index) const;
  ::sherlock::linear_combo* add_linear_terms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sherlock::linear_combo >&
      linear_terms() const;

  // bool direction = 2;
  void clear_direction();
  bool direction() const;
  void set_direction(bool value);

  // .sherlock.objective.optimization_status status_flag = 3;
  void clear_status_flag();
  ::sherlock::objective_optimization_status status_flag() const;
  void set_status_flag(::sherlock::objective_optimization_status value);

  // @@protoc_insertion_point(class_scope:sherlock.objective)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sherlock::linear_combo > linear_terms_;
  bool direction_;
  int status_flag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sherlock_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class sherlock_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sherlock.sherlock_message) */ {
 public:
  sherlock_message();
  virtual ~sherlock_message();

  sherlock_message(const sherlock_message& from);
  sherlock_message(sherlock_message&& from) noexcept
    : sherlock_message() {
    *this = ::std::move(from);
  }

  inline sherlock_message& operator=(const sherlock_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline sherlock_message& operator=(sherlock_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const sherlock_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const sherlock_message* internal_default_instance() {
    return reinterpret_cast<const sherlock_message*>(
               &_sherlock_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(sherlock_message& a, sherlock_message& b) {
    a.Swap(&b);
  }
  inline void Swap(sherlock_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline sherlock_message* New() const final {
    return CreateMaybeMessage<sherlock_message>(nullptr);
  }

  sherlock_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<sherlock_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const sherlock_message& from);
  void MergeFrom(const sherlock_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sherlock_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sherlock.sherlock_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sherlock_5fmessage_2eproto);
    return ::descriptor_table_sherlock_5fmessage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkDescriptionFieldNumber = 1,
    kInputIntervalFieldNumber = 2,
    kOutputIntervalFieldNumber = 3,
    kOptimizationProblemFieldNumber = 4,
    kStatusFlagFieldNumber = 5,
  };
  // .sherlock.network network_description = 1;
  bool has_network_description() const;
  void clear_network_description();
  const ::sherlock::network& network_description() const;
  ::sherlock::network* release_network_description();
  ::sherlock::network* mutable_network_description();
  void set_allocated_network_description(::sherlock::network* network_description);

  // .sherlock.interval input_interval = 2;
  bool has_input_interval() const;
  void clear_input_interval();
  const ::sherlock::interval& input_interval() const;
  ::sherlock::interval* release_input_interval();
  ::sherlock::interval* mutable_input_interval();
  void set_allocated_input_interval(::sherlock::interval* input_interval);

  // .sherlock.interval output_interval = 3;
  bool has_output_interval() const;
  void clear_output_interval();
  const ::sherlock::interval& output_interval() const;
  ::sherlock::interval* release_output_interval();
  ::sherlock::interval* mutable_output_interval();
  void set_allocated_output_interval(::sherlock::interval* output_interval);

  // .sherlock.objective optimization_problem = 4;
  bool has_optimization_problem() const;
  void clear_optimization_problem();
  const ::sherlock::objective& optimization_problem() const;
  ::sherlock::objective* release_optimization_problem();
  ::sherlock::objective* mutable_optimization_problem();
  void set_allocated_optimization_problem(::sherlock::objective* optimization_problem);

  // bool status_flag = 5;
  void clear_status_flag();
  bool status_flag() const;
  void set_status_flag(bool value);

  // @@protoc_insertion_point(class_scope:sherlock.sherlock_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::sherlock::network* network_description_;
  ::sherlock::interval* input_interval_;
  ::sherlock::interval* output_interval_;
  ::sherlock::objective* optimization_problem_;
  bool status_flag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sherlock_5fmessage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// network

// string onnx_filename = 1;
inline void network::clear_onnx_filename() {
  onnx_filename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& network::onnx_filename() const {
  // @@protoc_insertion_point(field_get:sherlock.network.onnx_filename)
  return onnx_filename_.GetNoArena();
}
inline void network::set_onnx_filename(const std::string& value) {
  
  onnx_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sherlock.network.onnx_filename)
}
inline void network::set_onnx_filename(std::string&& value) {
  
  onnx_filename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sherlock.network.onnx_filename)
}
inline void network::set_onnx_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  onnx_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sherlock.network.onnx_filename)
}
inline void network::set_onnx_filename(const char* value, size_t size) {
  
  onnx_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sherlock.network.onnx_filename)
}
inline std::string* network::mutable_onnx_filename() {
  
  // @@protoc_insertion_point(field_mutable:sherlock.network.onnx_filename)
  return onnx_filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* network::release_onnx_filename() {
  // @@protoc_insertion_point(field_release:sherlock.network.onnx_filename)
  
  return onnx_filename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void network::set_allocated_onnx_filename(std::string* onnx_filename) {
  if (onnx_filename != nullptr) {
    
  } else {
    
  }
  onnx_filename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), onnx_filename);
  // @@protoc_insertion_point(field_set_allocated:sherlock.network.onnx_filename)
}

// string old_format_filename = 2;
inline void network::clear_old_format_filename() {
  old_format_filename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& network::old_format_filename() const {
  // @@protoc_insertion_point(field_get:sherlock.network.old_format_filename)
  return old_format_filename_.GetNoArena();
}
inline void network::set_old_format_filename(const std::string& value) {
  
  old_format_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sherlock.network.old_format_filename)
}
inline void network::set_old_format_filename(std::string&& value) {
  
  old_format_filename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sherlock.network.old_format_filename)
}
inline void network::set_old_format_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  old_format_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sherlock.network.old_format_filename)
}
inline void network::set_old_format_filename(const char* value, size_t size) {
  
  old_format_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sherlock.network.old_format_filename)
}
inline std::string* network::mutable_old_format_filename() {
  
  // @@protoc_insertion_point(field_mutable:sherlock.network.old_format_filename)
  return old_format_filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* network::release_old_format_filename() {
  // @@protoc_insertion_point(field_release:sherlock.network.old_format_filename)
  
  return old_format_filename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void network::set_allocated_old_format_filename(std::string* old_format_filename) {
  if (old_format_filename != nullptr) {
    
  } else {
    
  }
  old_format_filename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), old_format_filename);
  // @@protoc_insertion_point(field_set_allocated:sherlock.network.old_format_filename)
}

// repeated int32 input_node_indices = 3;
inline int network::input_node_indices_size() const {
  return input_node_indices_.size();
}
inline void network::clear_input_node_indices() {
  input_node_indices_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 network::input_node_indices(int index) const {
  // @@protoc_insertion_point(field_get:sherlock.network.input_node_indices)
  return input_node_indices_.Get(index);
}
inline void network::set_input_node_indices(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  input_node_indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:sherlock.network.input_node_indices)
}
inline void network::add_input_node_indices(::PROTOBUF_NAMESPACE_ID::int32 value) {
  input_node_indices_.Add(value);
  // @@protoc_insertion_point(field_add:sherlock.network.input_node_indices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
network::input_node_indices() const {
  // @@protoc_insertion_point(field_list:sherlock.network.input_node_indices)
  return input_node_indices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
network::mutable_input_node_indices() {
  // @@protoc_insertion_point(field_mutable_list:sherlock.network.input_node_indices)
  return &input_node_indices_;
}

// repeated int32 output_node_indices = 4;
inline int network::output_node_indices_size() const {
  return output_node_indices_.size();
}
inline void network::clear_output_node_indices() {
  output_node_indices_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 network::output_node_indices(int index) const {
  // @@protoc_insertion_point(field_get:sherlock.network.output_node_indices)
  return output_node_indices_.Get(index);
}
inline void network::set_output_node_indices(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  output_node_indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:sherlock.network.output_node_indices)
}
inline void network::add_output_node_indices(::PROTOBUF_NAMESPACE_ID::int32 value) {
  output_node_indices_.Add(value);
  // @@protoc_insertion_point(field_add:sherlock.network.output_node_indices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
network::output_node_indices() const {
  // @@protoc_insertion_point(field_list:sherlock.network.output_node_indices)
  return output_node_indices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
network::mutable_output_node_indices() {
  // @@protoc_insertion_point(field_mutable_list:sherlock.network.output_node_indices)
  return &output_node_indices_;
}

// -------------------------------------------------------------------

// mapping

// int32 node_index = 1;
inline void mapping::clear_node_index() {
  node_index_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 mapping::node_index() const {
  // @@protoc_insertion_point(field_get:sherlock.mapping.node_index)
  return node_index_;
}
inline void mapping::set_node_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  node_index_ = value;
  // @@protoc_insertion_point(field_set:sherlock.mapping.node_index)
}

// float upper_limit = 2;
inline void mapping::clear_upper_limit() {
  upper_limit_ = 0;
}
inline float mapping::upper_limit() const {
  // @@protoc_insertion_point(field_get:sherlock.mapping.upper_limit)
  return upper_limit_;
}
inline void mapping::set_upper_limit(float value) {
  
  upper_limit_ = value;
  // @@protoc_insertion_point(field_set:sherlock.mapping.upper_limit)
}

// float lower_limit = 3;
inline void mapping::clear_lower_limit() {
  lower_limit_ = 0;
}
inline float mapping::lower_limit() const {
  // @@protoc_insertion_point(field_get:sherlock.mapping.lower_limit)
  return lower_limit_;
}
inline void mapping::set_lower_limit(float value) {
  
  lower_limit_ = value;
  // @@protoc_insertion_point(field_set:sherlock.mapping.lower_limit)
}

// -------------------------------------------------------------------

// interval

// repeated .sherlock.mapping limits = 1;
inline int interval::limits_size() const {
  return limits_.size();
}
inline void interval::clear_limits() {
  limits_.Clear();
}
inline ::sherlock::mapping* interval::mutable_limits(int index) {
  // @@protoc_insertion_point(field_mutable:sherlock.interval.limits)
  return limits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sherlock::mapping >*
interval::mutable_limits() {
  // @@protoc_insertion_point(field_mutable_list:sherlock.interval.limits)
  return &limits_;
}
inline const ::sherlock::mapping& interval::limits(int index) const {
  // @@protoc_insertion_point(field_get:sherlock.interval.limits)
  return limits_.Get(index);
}
inline ::sherlock::mapping* interval::add_limits() {
  // @@protoc_insertion_point(field_add:sherlock.interval.limits)
  return limits_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sherlock::mapping >&
interval::limits() const {
  // @@protoc_insertion_point(field_list:sherlock.interval.limits)
  return limits_;
}

// -------------------------------------------------------------------

// linear_combo

// float coefficient = 1;
inline void linear_combo::clear_coefficient() {
  coefficient_ = 0;
}
inline float linear_combo::coefficient() const {
  // @@protoc_insertion_point(field_get:sherlock.linear_combo.coefficient)
  return coefficient_;
}
inline void linear_combo::set_coefficient(float value) {
  
  coefficient_ = value;
  // @@protoc_insertion_point(field_set:sherlock.linear_combo.coefficient)
}

// int32 node_index = 2;
inline void linear_combo::clear_node_index() {
  node_index_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 linear_combo::node_index() const {
  // @@protoc_insertion_point(field_get:sherlock.linear_combo.node_index)
  return node_index_;
}
inline void linear_combo::set_node_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  node_index_ = value;
  // @@protoc_insertion_point(field_set:sherlock.linear_combo.node_index)
}

// -------------------------------------------------------------------

// objective

// repeated .sherlock.linear_combo linear_terms = 1;
inline int objective::linear_terms_size() const {
  return linear_terms_.size();
}
inline void objective::clear_linear_terms() {
  linear_terms_.Clear();
}
inline ::sherlock::linear_combo* objective::mutable_linear_terms(int index) {
  // @@protoc_insertion_point(field_mutable:sherlock.objective.linear_terms)
  return linear_terms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sherlock::linear_combo >*
objective::mutable_linear_terms() {
  // @@protoc_insertion_point(field_mutable_list:sherlock.objective.linear_terms)
  return &linear_terms_;
}
inline const ::sherlock::linear_combo& objective::linear_terms(int index) const {
  // @@protoc_insertion_point(field_get:sherlock.objective.linear_terms)
  return linear_terms_.Get(index);
}
inline ::sherlock::linear_combo* objective::add_linear_terms() {
  // @@protoc_insertion_point(field_add:sherlock.objective.linear_terms)
  return linear_terms_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sherlock::linear_combo >&
objective::linear_terms() const {
  // @@protoc_insertion_point(field_list:sherlock.objective.linear_terms)
  return linear_terms_;
}

// bool direction = 2;
inline void objective::clear_direction() {
  direction_ = false;
}
inline bool objective::direction() const {
  // @@protoc_insertion_point(field_get:sherlock.objective.direction)
  return direction_;
}
inline void objective::set_direction(bool value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:sherlock.objective.direction)
}

// .sherlock.objective.optimization_status status_flag = 3;
inline void objective::clear_status_flag() {
  status_flag_ = 0;
}
inline ::sherlock::objective_optimization_status objective::status_flag() const {
  // @@protoc_insertion_point(field_get:sherlock.objective.status_flag)
  return static_cast< ::sherlock::objective_optimization_status >(status_flag_);
}
inline void objective::set_status_flag(::sherlock::objective_optimization_status value) {
  
  status_flag_ = value;
  // @@protoc_insertion_point(field_set:sherlock.objective.status_flag)
}

// -------------------------------------------------------------------

// sherlock_message

// .sherlock.network network_description = 1;
inline bool sherlock_message::has_network_description() const {
  return this != internal_default_instance() && network_description_ != nullptr;
}
inline void sherlock_message::clear_network_description() {
  if (GetArenaNoVirtual() == nullptr && network_description_ != nullptr) {
    delete network_description_;
  }
  network_description_ = nullptr;
}
inline const ::sherlock::network& sherlock_message::network_description() const {
  const ::sherlock::network* p = network_description_;
  // @@protoc_insertion_point(field_get:sherlock.sherlock_message.network_description)
  return p != nullptr ? *p : *reinterpret_cast<const ::sherlock::network*>(
      &::sherlock::_network_default_instance_);
}
inline ::sherlock::network* sherlock_message::release_network_description() {
  // @@protoc_insertion_point(field_release:sherlock.sherlock_message.network_description)
  
  ::sherlock::network* temp = network_description_;
  network_description_ = nullptr;
  return temp;
}
inline ::sherlock::network* sherlock_message::mutable_network_description() {
  
  if (network_description_ == nullptr) {
    auto* p = CreateMaybeMessage<::sherlock::network>(GetArenaNoVirtual());
    network_description_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sherlock.sherlock_message.network_description)
  return network_description_;
}
inline void sherlock_message::set_allocated_network_description(::sherlock::network* network_description) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete network_description_;
  }
  if (network_description) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      network_description = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_description, submessage_arena);
    }
    
  } else {
    
  }
  network_description_ = network_description;
  // @@protoc_insertion_point(field_set_allocated:sherlock.sherlock_message.network_description)
}

// .sherlock.interval input_interval = 2;
inline bool sherlock_message::has_input_interval() const {
  return this != internal_default_instance() && input_interval_ != nullptr;
}
inline void sherlock_message::clear_input_interval() {
  if (GetArenaNoVirtual() == nullptr && input_interval_ != nullptr) {
    delete input_interval_;
  }
  input_interval_ = nullptr;
}
inline const ::sherlock::interval& sherlock_message::input_interval() const {
  const ::sherlock::interval* p = input_interval_;
  // @@protoc_insertion_point(field_get:sherlock.sherlock_message.input_interval)
  return p != nullptr ? *p : *reinterpret_cast<const ::sherlock::interval*>(
      &::sherlock::_interval_default_instance_);
}
inline ::sherlock::interval* sherlock_message::release_input_interval() {
  // @@protoc_insertion_point(field_release:sherlock.sherlock_message.input_interval)
  
  ::sherlock::interval* temp = input_interval_;
  input_interval_ = nullptr;
  return temp;
}
inline ::sherlock::interval* sherlock_message::mutable_input_interval() {
  
  if (input_interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::sherlock::interval>(GetArenaNoVirtual());
    input_interval_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sherlock.sherlock_message.input_interval)
  return input_interval_;
}
inline void sherlock_message::set_allocated_input_interval(::sherlock::interval* input_interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete input_interval_;
  }
  if (input_interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      input_interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_interval, submessage_arena);
    }
    
  } else {
    
  }
  input_interval_ = input_interval;
  // @@protoc_insertion_point(field_set_allocated:sherlock.sherlock_message.input_interval)
}

// .sherlock.objective optimization_problem = 4;
inline bool sherlock_message::has_optimization_problem() const {
  return this != internal_default_instance() && optimization_problem_ != nullptr;
}
inline void sherlock_message::clear_optimization_problem() {
  if (GetArenaNoVirtual() == nullptr && optimization_problem_ != nullptr) {
    delete optimization_problem_;
  }
  optimization_problem_ = nullptr;
}
inline const ::sherlock::objective& sherlock_message::optimization_problem() const {
  const ::sherlock::objective* p = optimization_problem_;
  // @@protoc_insertion_point(field_get:sherlock.sherlock_message.optimization_problem)
  return p != nullptr ? *p : *reinterpret_cast<const ::sherlock::objective*>(
      &::sherlock::_objective_default_instance_);
}
inline ::sherlock::objective* sherlock_message::release_optimization_problem() {
  // @@protoc_insertion_point(field_release:sherlock.sherlock_message.optimization_problem)
  
  ::sherlock::objective* temp = optimization_problem_;
  optimization_problem_ = nullptr;
  return temp;
}
inline ::sherlock::objective* sherlock_message::mutable_optimization_problem() {
  
  if (optimization_problem_ == nullptr) {
    auto* p = CreateMaybeMessage<::sherlock::objective>(GetArenaNoVirtual());
    optimization_problem_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sherlock.sherlock_message.optimization_problem)
  return optimization_problem_;
}
inline void sherlock_message::set_allocated_optimization_problem(::sherlock::objective* optimization_problem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete optimization_problem_;
  }
  if (optimization_problem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      optimization_problem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, optimization_problem, submessage_arena);
    }
    
  } else {
    
  }
  optimization_problem_ = optimization_problem;
  // @@protoc_insertion_point(field_set_allocated:sherlock.sherlock_message.optimization_problem)
}

// .sherlock.interval output_interval = 3;
inline bool sherlock_message::has_output_interval() const {
  return this != internal_default_instance() && output_interval_ != nullptr;
}
inline void sherlock_message::clear_output_interval() {
  if (GetArenaNoVirtual() == nullptr && output_interval_ != nullptr) {
    delete output_interval_;
  }
  output_interval_ = nullptr;
}
inline const ::sherlock::interval& sherlock_message::output_interval() const {
  const ::sherlock::interval* p = output_interval_;
  // @@protoc_insertion_point(field_get:sherlock.sherlock_message.output_interval)
  return p != nullptr ? *p : *reinterpret_cast<const ::sherlock::interval*>(
      &::sherlock::_interval_default_instance_);
}
inline ::sherlock::interval* sherlock_message::release_output_interval() {
  // @@protoc_insertion_point(field_release:sherlock.sherlock_message.output_interval)
  
  ::sherlock::interval* temp = output_interval_;
  output_interval_ = nullptr;
  return temp;
}
inline ::sherlock::interval* sherlock_message::mutable_output_interval() {
  
  if (output_interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::sherlock::interval>(GetArenaNoVirtual());
    output_interval_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sherlock.sherlock_message.output_interval)
  return output_interval_;
}
inline void sherlock_message::set_allocated_output_interval(::sherlock::interval* output_interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete output_interval_;
  }
  if (output_interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      output_interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output_interval, submessage_arena);
    }
    
  } else {
    
  }
  output_interval_ = output_interval;
  // @@protoc_insertion_point(field_set_allocated:sherlock.sherlock_message.output_interval)
}

// bool status_flag = 5;
inline void sherlock_message::clear_status_flag() {
  status_flag_ = false;
}
inline bool sherlock_message::status_flag() const {
  // @@protoc_insertion_point(field_get:sherlock.sherlock_message.status_flag)
  return status_flag_;
}
inline void sherlock_message::set_status_flag(bool value) {
  
  status_flag_ = value;
  // @@protoc_insertion_point(field_set:sherlock.sherlock_message.status_flag)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sherlock

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sherlock::objective_optimization_status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sherlock::objective_optimization_status>() {
  return ::sherlock::objective_optimization_status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sherlock_5fmessage_2eproto
